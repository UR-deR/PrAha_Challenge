## DDD を学ぶ応用

### 課題 1

**認証状態に基づくアクセス制御をどのレイヤーで行うか**

認証後のインターフェースをアプリケーション層で定義し、アクセス制御はアプリケーション層で行う。

その他のレイヤーを除外した理由は以下の通り。消去法的にアプリケーション層で行う。

1. インフラ層

インフラ層はDB や外部サービスとの通信・操作、リポジトリやクエリサービスの実装などを行うレイヤーである。
投稿をする・しないなどのユースケースに関わる記述を行うレイヤーでは無いため除外。

2. プレゼンテーション層

プレゼンテーション層は、クライアントサイドとの通信や、UI についての関心を持つレイヤーである。
認証状態に基づいて投稿する or しないなどのユースケースの記述を行うレイヤーではないため除外。

3. ドメイン層
認証後のインターフェースをアプリケーション層で定義しているため、ドメイン層は認証後のインターフェースを用いることができない。よって、除外。

> 認証後のインターフェースをアプリケーション層で定義する理由

消去法で考える。
- インフラ層・プレゼンテーション層: 
認証後のインターフェースを用いて投稿する　or しないをアプリケーション層で切り替えるが、インフラ層やプレゼンテーション層に認証後のインターフェースを定義してしまうと、アプリケーション層で認証後のインターフェースを用いた処理を書くことができない。したがって、除外。

- ドメイン層: 
認証状態はwebアプリケーション固有の概念であり、ドメインには存在しない概念だと考えたため、ドメイン層に認証後のインターフェースを定義するのは違うのでは無いかと考えました。

以上より、消去法でアプリケーション層で定義する。

**どのレイヤーでトークンを検証して認証フラグを更新するか**

→**プレゼンテーション層**で行う。

前述の通り、アプリケーション層に認証後のインターフェースを定義しているため、オニオンアーキテクチャの依存の方向性に従うとこの時点でドメイン層は選択肢から除外される。
requestに含まれるtokenを用いて認証を実現する、というHOWの知識はユースケース層に漏れないようにしたいので、プレゼンテーション層で行う。
インフラ層は、requestについての知識を持ってはいけないのでNG。

ユースケース層：認証後のインターフェースを定義→アプリケーション層のテストが書きやすくなる。

```ts
interface User {
   isLoggedIn: boolean;
   role: Role[]
}
```

プレゼンテーション層：認証の具体的な実装を行う。アプリケーション層に認証の実装の知識が漏れないようにする。