## DDD を学ぶ応用

### 課題 1

**認証状態に基づくアクセス制御をどのレイヤーで行うか**

認証後のインターフェースをアプリケーション層で定義し、アクセス制御はアプリケーション層で行う。

その他のレイヤーを除外した理由は以下の通り。消去法的にアプリケーション層で行う。

1. インフラ層

インフラ層は DB や外部サービスとの通信・操作、リポジトリやクエリサービスの実装などを行うレイヤーである。
投稿をする・しないなどのユースケースに関わる記述を行うレイヤーでは無いため除外。

2. プレゼンテーション層

プレゼンテーション層は、クライアントサイドとの通信や、UI についての関心を持つレイヤーである。
認証状態に基づいて投稿する or しないなどのユースケースの記述を行うレイヤーではないため除外。

3. ドメイン層
   認証後のインターフェースをアプリケーション層で定義しているため、ドメイン層は認証後のインターフェースを用いることができない。よって、除外。

> 認証後のインターフェースをアプリケーション層で定義する理由

消去法で考える。

- インフラ層・プレゼンテーション層:
  認証後のインターフェースを用いて投稿する　 or しないをアプリケーション層で切り替えるが、インフラ層やプレゼンテーション層に認証後のインターフェースを定義してしまうと、アプリケーション層で認証後のインターフェースを用いた処理を書くことができない。したがって、除外。

- ドメイン層:
  認証状態は web アプリケーション固有の概念であり、ドメインには存在しない概念だと考えたため、ドメイン層に認証後のインターフェースを定義するのは違うのでは無いかと考えました。

以上より、消去法でアプリケーション層で定義する。

**どのレイヤーでトークンを検証して認証フラグを更新するか**

→**プレゼンテーション層**で行う。

前述の通り、アプリケーション層に認証後のインターフェースを定義しているため、オニオンアーキテクチャの依存の方向性に従うとこの時点でドメイン層は選択肢から除外される。
request に含まれる token を用いて認証を実現する、という HOW の知識はユースケース層に漏れないようにしたいので、プレゼンテーション層で行う。
インフラ層は、request についての知識を持ってはいけないので NG。

ユースケース層：認証後のインターフェースを定義 → アプリケーション層のテストが書きやすくなる。

```ts
interface User {
  isLoggedIn: boolean;
  role: Role[];
}
```

プレゼンテーション層：認証の具体的な実装を行う。アプリケーション層に認証の実装の知識が漏れないようにする。

**User エンティティに認証についてのプロパティを設けることの是非**

ドメイン層の User エンティティに認証に関してのプロパティを追加すると、User エンティティが肥大化してしまう。
また、それらの認証に関わるプロパティはドメインロジックとして使うための値ではなく、認証のためだけに使われる値である場合、ドメイン層の User エンティティにとってはノイズになるので設けるべきではないと思う。

**超過文字数エラーの対処について**

**用語**

**Result 型**

バリデーションに引っかかった時などに Error を投げることがあるが、Error を投げるかどうかは関数の実装を見ないと知ることができない（関数シグネチャからは読み取れない。）
したがって、try-catch を忘れてしまいうる状況になっている。
しかし、以下のような Result 型を定義し、関数の戻り値の型として定義すれば、try-catch は書かなくてよくなり、成功時と失敗時のケースを必ず書くようになる。

```ts
export type Ok<T> = { ok: true; value: T };
export type Err<E> = { ok: false; error: E };
export type Result<T, E> = Ok<T> | Err<E>;
```

### 検査例外

Exception クラスのサブクラスのうち、RuntimeException クラス配下以外の例外クラス。
try-catch が必要。しないと、コンパイルエラーになる。

例

- IOException
- SQLException
- ClassNotFoundException

### 非検査例外

Exception クラスのサブクラスうち、RuntimeException クラス配下の例外クラス。
try-catch は不必要。

例

- NullPointerException
- ArrayIndexOutOfBoundsException
- IllegalArgumentException

### ドメインイベント

ドメインイベントはドメインで発生する出来事であり、それを同じドメインの他の部分に認識させる。他の部分は通知を受けると、イベントに何らかの方法で対処します。
ドメインイベントの重要な利点は、副作用を明示的に表現できることである。
ドメインイベントとその副作用 (その後にトリガーされる、イベント ハンドラーによって管理されるアクション) は、ほぼ瞬時に (通常はインプロセス) 同じドメイン内で発生する必要がある。 したがって、ドメインイベントは同期でも非同期でもかまわない。
