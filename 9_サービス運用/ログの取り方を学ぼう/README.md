# ログの取り方を学ぼう
## 課題1
### ログレベル
ログレベルとは、アプリケーションが出力するログの重要度や緊急度を分類する基準であり、次のようなレベルがある：  

- DEBUG: 開発者向けの詳細なデバッグ情報を出力。  
- INFO: システムの正常動作に関する情報。  
- WARN: 問題の可能性がある状況を示す警告。  
- ERROR: システムの一部が正常に機能しないエラー。  
- FATAL: システム全体の動作に深刻な影響を与える重大なエラー。  

ログレベルを指定することで、以下のメリットが得られる：  

- 効率的なトラブルシューティング: 開発や運用時に適切なログをフィルタリングして問題を迅速に特定できる。  
- システム監視の向上: WARNやERRORレベルのログに注目することで、潜在的な問題を早期に察知可能。  
- ストレージの節約: 不要な詳細ログ（DEBUGなど）を本番環境で抑えることで、ログデータの量を最適化。  
- セキュリティ: 本番環境で重要度の低いログ（DEBUGなど）を出力しないことで、機密情報漏洩を防ぐ。  

運用環境では通常、INFO以上を記録し、開発環境ではDEBUGを含むすべてのログを出力するのが一般的。

### アプリケーションログに含めるべき情報  
- タイムスタンプ: イベント発生時刻を記録。ログの順序や問題発生時刻を特定するために必須。  
- 各イベントの重要度（例: DEBUG, INFO, WARN, ERROR）。  
- メッセージ: イベントの内容を簡潔に説明するテキスト。  
- イベントの発生元: ログを生成したモジュール、クラス、または関数名。  
- リクエストIDやトランザクションID: 特定のリクエストや処理に関連するログを追跡するための識別子。  
- ユーザー情報（適宜）: 問題の影響を受けたユーザーを特定するための非機密的な識別子（例: ユーザーID、セッションID）。  
- エラー詳細（スタックトレースなど）: エラー発生時に原因を特定するための情報。 

### ログに含めない方が良い情報  
- 個人情報（PII）: 氏名、住所、電話番号、メールアドレスなど。これらはデータ保護法（例: GDPR、CCPA）に抵触する可能性がある。  
- 認証情報: パスワード、APIキー、アクセストークンなど。これが漏洩すると重大なセキュリティリスクを招く。  
- 機密情報: 財務データ、契約情報、またはその他の機密情報。  
- 過剰な詳細情報: 容易に理解できない冗長なデバッグ情報は、ログ量を増加させ、必要な情報を見つけにくくする。  
- ユーザー生成コンテンツ: フォーム入力やコメント欄の内容など、制御不能な情報。意図しないリスクが生じる可能性がある。  

### ログの出力タイミング

1. アプリケーションの起動・終了時  
- INFO: アプリケーションが開始されたことや、終了プロセスが正常に行われたことを記録する。  

2. 正常系の処理が終了したとき  
- INFO: 重要な処理が正常に完了したことを記録する。  
  - 例: ユーザーがログインした、データが正常に保存された、外部APIとの通信が成功した。

3. 例外が生じたとき  
- ERROR: 処理が失敗した場合や例外が発生した際に記録する。  
  - 例: データベース接続エラー、APIレスポンスエラー、ファイルの読み取り失敗。  

4. 重大な障害が発生したとき  
- FATAL: システム全体が停止するような重大なエラーを記録する。
  - 例: サーバーのメモリ不足、依存コンポーネントの不可逆的な障害。  

5. 警告が必要な状況
- WARN: 問題は発生していないが、潜在的にリスクがある状況を記録する。  
  - 例: キャッシュの有効期限切れ、非推奨機能の使用

6. 開発やデバッグ時の詳細な情報出力  
- DEBUG: 開発中に処理の詳細を追跡するためのログ。通常、本番環境では出力しない。  
  - 例: メソッドの開始/終了、変数の値、SQLクエリの内容。  

7. 外部リソースとの通信時  
- INFOまたはDEBUG: 外部システムやサービスとの通信を記録する。  
  - 例: リクエスト送信時、レスポンスのステータスコード。DEBUGの場合は、リクエスト/レスポンスの詳細（例: ヘッダーやボディ）も記録。

8. 重要な設定変更や操作が行われたとき  
- INFOまたはWARN: システムやデータの状態に影響を与える操作を記録する。  
  - 例: ユーザーの権限変更、設定ファイルの更新。  

### ログメッセージのフォーマット
ログメッセージをJSON形式で出力すれば、各種ログ解析ツール(ClowdWatch Logs, Fluentbit)でパースできるため扱いやすくなる。

- [Analyzing log data with CloudWatch Logs Insights - Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html)
- [JSON | Fluent Bit: Official Manual](https://docs.fluentbit.io/manual/pipeline/parsers/json)

[Logstash Logback Encoder](https://mvnrepository.com/artifact/net.logstash.logback/logstash-logback-encoder)などを用いることで、容易にJSONフォーマットでログを出力できるようになる。

### ログの種類

**アクセスログ**  
システムやウェブサーバーへのリクエスト情報を記録するログ。  
- リクエスト元のIPアドレス  
- アクセスした日時（タイムスタンプ）  
- リクエストされたURLやパス  
- HTTPメソッド（GET、POSTなど）  
- ステータスコード（200, 404, 500など）  
- ユーザーエージェント（ブラウザ情報など）  
- リファラー（どのページからアクセスしたか）  

**アプリケーションログ**  
アプリケーション内部の動作やイベントを記録するログ。  
- アプリケーションの開始・終了  
- 各種操作やビジネスロジックの処理状況（例: データの保存、メール送信）  
- ユーザーアクション（例: ログイン、購入）  
- 外部APIとの通信状況  
- 例外やエラー（エラーログと重複する場合もある）  


**エラーログ**  
アプリケーションやシステムで発生したエラーを記録するログ。  
- エラーの発生時刻  
- エラー内容（例: データベース接続失敗、ファイルの読み込み失敗）  
- エラー発生箇所（例: クラス名、関数名、スタックトレース）  
- 関連するリクエストやセッション情報  

**（フロントエンドの）ユーザーログ**  
クライアントサイドで発生するイベントやエラーを記録するログ。  
フロントエンドのパフォーマンス監視のゴールは、動き続けることではなく素早くロードされることである。
  - ユーザーの操作（クリック、スクロール、フォーム入力など）  
  - ページ遷移やロード時間  
  - クライアントサイドで発生したエラー

**データベースのクエリログ**  
データベースに対して実行されたSQLクエリを記録するログ。  
- 実行されたSQL文
- クエリの実行時間  
- クエリの発行元（アプリケーション名やユーザーID）  
- クエリの結果（成功/失敗）  

### ログローテーション
一定の条件（サイズ、日付など）でログファイルを切り分け、古いログを削除またはアーカイブする運用手法。  
- 新しいログファイルの生成: 古いログをリネームし、新しいログファイルに出力を切り替える。  
  例: `app.log` → `app.log.1` → `app.log.2.gz`（圧縮形式）。  
- 古いログの管理: 保存期間を過ぎたログを削除、または外部ストレージにアーカイブ。  

**メリット**
1. ストレージの節約
   - ログファイルが肥大化するのを防ぎ、ディスク容量の枯渇を回避。  
2. パフォーマンスの向上
   - 大きなログファイルは検索や解析が遅くなるため、ファイルを分割することで処理が高速化。  
3. 運用管理の効率化
   - 古いログを自動的に削除または圧縮することで、運用負荷を軽減。  
4. 障害時の影響を軽減
   - ファイル肥大化によるシステムダウンを防ぎ、障害対応の迅速化を実現。  

**デメリット**
1. 設定の複雑さ
   - ログローテーションの条件（サイズや日付）や保存ポリシーの設定が煩雑になる場合がある。  
2. ログファイル切り替え時のリスク
   - ローテーションのタイミングでログ出力が一時的に中断されることがある（特にローテーションが同期的に実行される場合）。  
3. 監視の手間
   - ログの世代管理が不十分だと、必要なログが失われる可能性がある。  
4. 分散管理が困難
   - 複数サーバー間での一貫したログ管理が難しい場合がある。  

**ログローテーションの頻度が減っている背景**

1. クラウドサービスやマネージドログ管理ツールの普及
   - クラウドサービスでは、ログが中央で一元管理されるため、手動でログをローテーションする必要がなくなった。  
   - 自動的にログの圧縮やアーカイブ、削除を行い、設定も簡単。  

2. ストレージコストの低下
   - クラウドストレージの価格が下がり、ログを長期間保存してもコストが抑えられるようになったため、古いログを頻繁に削除する必要性が低下。  

### サービスが稼働するインスタンスにログファイルを保存するのは避けた方が良い理由
1. スケーラビリティの制約
- 理由: モダンなシステムでは、スケーリングのために複数のインスタンスを動的に起動・停止することが一般的。この場合、各インスタンスに分散されたログを管理するのは困難になる。  
- 問題点:  
  - インスタンスが停止するとログも失われる。  
  - どのインスタンスのログにエラーが記録されているかを特定するのが難しい。  

2. ログの可用性と耐久性の低下  
- 理由: インスタンスがクラッシュしたり削除された場合、そのインスタンスに保存されていたログも失われる可能性がある。  
- 問題点:  
  - 障害発生時のトラブルシューティングが不可能になる。  
  - 長期間のログ保存が必要な場合、インスタンスのストレージに依存する運用では不適切。  

3. ストレージの枯渇
- 理由: ログファイルがインスタンスのディスク容量を占有するため、ディスクの枯渇リスクが高まる。  
- 問題点:  
  - ディスクが満杯になると、アプリケーションやシステムの正常な動作に支障をきたす。  
  - 特に動的にスケーリングされる環境では、インスタンスの容量管理が難しい。  

4. 分析や可視化が困難 
- 理由: ログが各インスタンスに分散していると、ログの収集、統合、分析が複雑化する。  
- 問題点:  
  - 複数のインスタンスのログをリアルタイムで監視する仕組みが必要。  
  - 分散されたログを収集するために、追加のシステムやツールが必要になる。  

### 「プル型」と「プッシュ型」
**プル型（Pull Model）**  
ログ収集システムが、ログを出力する対象（サーバーやアプリケーション）に問い合わせを行い、必要なログを取得する方式。

**メリット**  
1. 柔軟な取得タイミング
   - ログ収集システム側でスケジュールを設定できるため、負荷が少ないタイミングでログを取得可能。  
2. ログの選択的取得
   - 必要なログだけを問い合わせることで、不要なデータの収集を防げる。  
3. シンプルな送信側の設計
   - ログを送信する仕組みを個々のアプリケーションに実装する必要がない。ログ出力だけに集中できる。  

**デメリット**  
1. リアルタイム性に欠ける
   - ログ収集の間隔が長い場合、最新のログが監視に反映されるまで時間がかかる。  
2. スケーリングが難しい
   - 多数のサーバーやインスタンスに対して定期的に問い合わせると、収集システムに負荷がかかる。  
3. 一時的な接続問題への脆弱性
   - 対象のサーバーやインスタンスにアクセスできない場合、ログが取りこぼされる可能性がある。  

**使い所**  
- オンプレミス環境: ネットワーク内の特定サーバーからログを収集する場合。  
- 低頻度な監査や解析: アクセスログや定期的なレポート生成など、リアルタイム性が求められない場合。  

**プッシュ型（Push Model）**  
ログを出力する側（アプリケーションやサーバー）が、ログ収集システムに対してデータを送信する方式。

**メリット**  
1. リアルタイム性が高い
   - ログが発生するたびに即座に送信されるため、迅速な監視や分析が可能。  
2. スケーラブル
   - ログ収集システムがアクティブに問い合わせを行わないため、多数のインスタンスから効率よくデータを集約できる。  
3. ローカルストレージ依存の低減
   - ログをすぐに外部システムに送信するため、サーバー内のストレージ消費を抑えられる。  

**デメリット**  
1. 送信側の実装が必要
   - 各アプリケーションやサーバーにログ送信の仕組みを組み込む必要がある。  
2. ネットワーク依存度が高い
   - ネットワーク障害時にログが送信できず、データが失われるリスクがある（バッファリングや再送機能が必要）。  
3. 送信エラーの管理が必要  
   - ログ送信失敗時のリトライ処理やエラー管理が必要となる。  

**使い所**  
- クラウド環境: 動的にスケーリングするインスタンスやコンテナ環境で、リアルタイムのログ収集が必要な場合。  
- 監視やアラート: エラーログやシステム障害など、即時対応が求められる状況。  
- 分散システム: 分散アーキテクチャでログを一元管理する場合。  

## 課題2
- 秘匿情報が引数の値に含まれている場合、流出のリスクが高まる
- 悪意のある文字列が引数に含まれている場合に、予期せぬ攻撃を受ける可能性がある（マルウェアをダウンロードさせ、Webサーバーにマルウェアを感染させるなど）
